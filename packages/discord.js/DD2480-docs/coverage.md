# Coverage measurement and Improvement

## Task 1: DIY
Manual instrumentation of the cyclomatic complexity for each function, answer these questions.

- What is the quality of your own coverage measurement? Does it take into account ternary operators
(condition ? yes : no) and exceptions, if available in your language?
- What are the limitations of your tool? How would the instrumentation change if you modify the
program?
- If you have an automated tool, are your results consistent with the ones produced by existing tool(s)?

### Function 1 - Carl

### Function 2 - Klara

### Function 3 - Jacob

### Function 4 - Phoebe

### Function 5 - Samuel

## Task 2: Coverage improvement
Keep a copy of your original coverage, try to improve coverage with additional test cases on a new branch. 
- Identify the requirements that are tested or untested by the given test suite.
- Document the requirements (as comments), and use them later as assertions.
- Create new test cases as needed to improve branch coverage in the given functions. Can you call the function directly? Can you expand on existing tests? Do you have to add additional interfaces to the system (as public methods) to make it possible to set up test data structures?

### Function 1 - Carl

### Function 2 - Klara

### Function 3 - Jacob

### Function 4 - Phoebe

### Function 5 - Samuel

# Task 3: Refactoring Plan

Is the high complexity you identified really necessary? Is it possible to split up the code (in the five complex functions you have identified) into smaller units to reduce complexity? If so, how would you go about this? Document your plan.

### Function 1 - Carl

### Function 2 - Klara

### Function 3 - Jacob

### Function 4 - Phoebe

### Function 5 - Samuel

